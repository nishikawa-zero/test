/*
*    Class implementation of the SoC Designer component <SD_AXIv2_DummyGraphicsMacroModel2Axi>
*
*    This code has been generated by the SoC Designer Component Wizard.
*    Copyright (c)  2008-2010 Carbon Design Systems Inc.
*
* THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND TRADE SECRETS OF CARBON
* DESIGN SYSTEMS, INC.  PERMISSION IS HEREBY GRANTED TO USE, MODIFY, AND/OR COPY
* THIS SOFTWARE FOR INTERNAL USE ONLY PROVIDED THAT THE ABOVE COPYRIGHT NOTICE
* APPEARS IN ALL COPIES OF THIS SOFTWARE.
*/

#include "SD_AXIv2_DummyGraphicsMacroModel2Axi.h"

#include <iostream>
#include <cstdio>

#include "ProtocolUtils.h"

#include "DummyGraphicsMacroModel_AXI_Master_Port.h"
#include "DummyGraphicsMacroModel_interrupt_SS.h"
#include "DummyGraphicsMacroModel_reset_x_SS.h"

SD_AXIv2_DummyGraphicsMacroModel2Axi::SD_AXIv2_DummyGraphicsMacroModel2Axi(CASIModuleIF* c, const string &s) : CASIModule(c, s)
{
	uint32_t i;
	char strBuffer[1000];

  for (unsigned int i = 0; i < 2; ++i) {
    std::stringstream ss;
    std::string port_name;

    ss << "AXIv2_master_" << i;
    ss >> port_name;
    AXIv2_master_TMaster[i] = new DummyGraphicsMacroModel_AXI_Master_Port<SD_AXIv2_DummyGraphicsMacroModel2Axi>( this, port_name );
    initAXIv2TransactionPort((CASITransactionMasterIF*)AXIv2_master_TMaster[i]);
    registerPort( AXIv2_master_TMaster[i], port_name.c_str() );
  }

	// interrupt x 4
	for ( i = 0; i < 4; i++ )
	{
		sprintf ( strBuffer, "interrupt%d", i );
		DummyGraphicsMacroModel2Axi_interrupt_SSlave[i] = new DummyGraphicsMacroModel_interrupt_SS<SD_AXIv2_DummyGraphicsMacroModel2Axi>( this, i );
		registerPort( DummyGraphicsMacroModel2Axi_interrupt_SSlave[i], strBuffer );
	}

	// output x 4
	for ( i = 0; i < 4; i++ )
	{
		sprintf ( strBuffer, "output%d", i );
		output_SMaster[i] = new sc_port<CASISignalIF>(this, strBuffer );
		sprintf ( strBuffer, "output%d", i );
		initSignalPort((CASISignalMasterIF*)output_SMaster[i]);
		registerPort( output_SMaster[i], strBuffer );
	}

	DummyGraphicsMacroModel2Axi_reset_x_SSlave = new DummyGraphicsMacroModel_reset_x_SS<SD_AXIv2_DummyGraphicsMacroModel2Axi>( this );
	registerPort( DummyGraphicsMacroModel2Axi_reset_x_SSlave, "reset_x" );

	// Clocking the components
	SC_MX_CLOCKED();
	// Register ourself as a clock slave port.
	registerPort( dynamic_cast< CASIClockSlaveIF* >( this ), "clk-in");

	// Place parameter definitions here:
  defineParameter( "Enable Debug Messages", "false", eslapi::CASI_PARAM_BOOL);
	defineParameter( "model_id",                 "0", eslapi::CASI_PARAM_VALUE,  0);
	defineParameter( "rch_number",               "2", eslapi::CASI_PARAM_VALUE,  0);
	defineParameter( "wch_number",               "2", eslapi::CASI_PARAM_VALUE,  0);
	defineParameter( "core_number",              "1", eslapi::CASI_PARAM_VALUE,  0);
	defineParameter( "read_outstanding_number",  "4", eslapi::CASI_PARAM_VALUE,  0);
	defineParameter( "write_outstanding_number", "4", eslapi::CASI_PARAM_VALUE,  0);
	defineParameter( "no_r_receive",         "false", eslapi::CASI_PARAM_BOOL,   0);
	defineParameter( "no_b_receive",         "false", eslapi::CASI_PARAM_BOOL,   0);
	defineParameter( "time_unit",                                 "SC_NS", eslapi::CASI_PARAM_STRING, 0);
	defineParameter( "axi_clock",                                    "10", eslapi::CASI_PARAM_VALUE,  0);
	defineParameter( "core_clock",                                   "10", eslapi::CASI_PARAM_VALUE,  0);
	defineParameter( "buffer_parameter_file_name", "buffer_parameter.csv", eslapi::CASI_PARAM_STRING, 0);
	defineParameter( "output_vcd_file_name",             "result_vcd.vcd", eslapi::CASI_PARAM_STRING, 0);
	defineParameter( "output_csv_file_name",             "result_csv.csv", eslapi::CASI_PARAM_STRING, 0);
	defineParameter( "output_summary_file_name",     "result_summary.csv", eslapi::CASI_PARAM_STRING, 0);
	defineParameter( "Data Width",                                   "64", eslapi::CASI_PARAM_VALUE,  0);
	defineParameter( "Address Width",                                "32", eslapi::CASI_PARAM_VALUE,  0);
}

SD_AXIv2_DummyGraphicsMacroModel2Axi::~SD_AXIv2_DummyGraphicsMacroModel2Axi()
{
	uint32_t i;

	// Release all resources.
	for ( i = 0; i < 2; i++ )
    delete AXIv2_master_TMaster[i];
	for ( i = 0; i < 4; i++ )
		delete DummyGraphicsMacroModel2Axi_interrupt_SSlave[i];
	for ( i = 0; i < 4; i++ )
		delete output_SMaster[i];
	delete DummyGraphicsMacroModel2Axi_reset_x_SSlave;

}

void SD_AXIv2_DummyGraphicsMacroModel2Axi::communicate()
{
	// the following message will be printed only in the debug version of MxExplorer
	if (p_enableDbgMsg == true)
	{
		message(eslapi::CASI_MSG_INFO,"Executing communicate function");
	}

	// TODO:  Add your communicate code here.
	// ...

  for (unsigned int i = 0; i < 2; ++i) {
    AXIv2_master_TMaster[i]->sendDrive();
  }

	/* FSL code begin */
	doneSendAW();
	doneSendW();
	doneSendAR();

	getsendB();
	getsendR();
	/* FSL code end */
}

void SD_AXIv2_DummyGraphicsMacroModel2Axi::update()
{
	// the following message will be printed only in the debug version of MxExplorer
	if (p_enableDbgMsg == true)
	{
		message(eslapi::CASI_MSG_INFO,"Executing update function");
	}

	// TODO:  Add your update code here.
	// ...

	/* FSL code begin */
	getsendAW();
	getsendW();
	getsendAR();

	controlOutput();
	/* FSL code end */
}

/* FSL code begin */
void
	SD_AXIv2_DummyGraphicsMacroModel2Axi::doneSendAW(void)
{
  for (unsigned int i = 0; i < 2; ++i) {
    if(AXIv2_master_TMaster[i]->getSig(AW_VALID) && AXIv2_master_TMaster[i]->getSig(AW_READY))
    {
#ifdef ABSTFR_TIMESTAMP
      cout << "[abstFR] AW send :: core_id = " << p_core_id << " , sc_time = " << sc_time_stamp() << endl;
#endif
      /* AW_VALID,AW_READYともに1であれば、AW送信できたと判断する */
      /* フラグを上げてBREADY=1にする */
      AXIv2_master_TMaster[i]->m_aw_done_flag = 1;
      m_b_count++;
      switch(p_Data_Bit_Width){
      case 64:
        core_64->m_transreceiver[i]->popAWTransaction();
        break;
      default:
        message(eslapi::CASI_MSG_WARNING,
                "SD_AXIv2_DummyGraphicsMacroModel2Axi::doneSendAW: p_Data_Bit_Width <%d> is not supported.",
                p_Data_Bit_Width);
        break;
      }
    }
  }
}

void
	SD_AXIv2_DummyGraphicsMacroModel2Axi::doneSendW(void)
{
  for (unsigned int i = 0; i < 2; ++i) {
    if(AXIv2_master_TMaster[i]->getSig(W_VALID) && AXIv2_master_TMaster[i]->getSig(W_READY))
    {
      /*#ifdef ABSTFR_TIMESTAMP
        cout << "[abstFR] W send :: core_id = " << p_core_id << " , sc_time = " << sc_time_stamp() << endl;
        #endif*/
      if(AXIv2_master_TMaster[i]->getSig(W_LAST))
      {
        /* W_VALID,W_READYともに1であれば、W送信できたと判断する */
        /* W_LAST == 1によりW転送完了を判断し、フラグを上げてBREADY=1にする */
        AXIv2_master_TMaster[i]->m_w_done_flag = 1;
      }
      switch(p_Data_Bit_Width){
      case 64:
        core_64->m_transreceiver[i]->popWTransaction();
        break;
      default:
        message(eslapi::CASI_MSG_WARNING,
                "SD_AXIv2_DummyGraphicsMacroModel2Axi::doneSendW: p_Data_Bit_Width <%d> is not supported.",
                p_Data_Bit_Width);
        break;
      }
    }
  }
}

void
	SD_AXIv2_DummyGraphicsMacroModel2Axi::doneSendAR(void)
{
  for (unsigned int i = 0; i < 2; ++i) {
    if(AXIv2_master_TMaster[i]->getSig(AR_VALID) && AXIv2_master_TMaster[i]->getSig(AR_READY))
    {
#if 0
      std::cout << sc_time_stamp() << " doneSendAR" << std::endl;
#endif

#ifdef ABSTFR_TIMESTAMP
      cout << "[abstFR] AR send :: core_id = " << p_core_id << " , sc_time = " << sc_time_stamp() << endl;
#endif
      /* AR_VALID,AR_READYともに1であれば、AR送信できたと判断する */
      /* フラグを上げてRREADY=1にする */
      AXIv2_master_TMaster[i]->m_ar_done_flag = 1;
      
      switch(p_Data_Bit_Width){
      case 64:
        core_64->m_transreceiver[i]->popARTransaction();
        break;
      default:
        message(eslapi::CASI_MSG_WARNING,
                "SD_AXIv2_DummyGraphicsMacroModel2Axi::doneSendAR: p_Data_Bit_Width <%d> is not supported.",
                p_Data_Bit_Width);
        break;
      }
    }
  }
}

void
	SD_AXIv2_DummyGraphicsMacroModel2Axi::getsendAW(void)
{
  for (unsigned int i = 0; i < 2; ++i) {
    switch(p_Data_Bit_Width){
    case 64:
    {
      axi_payload<DATA_WIDTH_64>* aw_transaction = NULL;
      aw_transaction = core_64->m_transreceiver[i]->frontAWTransaction();
      if(aw_transaction)
      {
				/* AWキューにトランザクションがあればAWをセットする */
				AXIv2_master_TMaster[i]->setAW(1, // AWVALID
                                       aw_transaction->getAWID(),
                                       (uint64_t)aw_transaction->getAWADDR(),
                                       aw_transaction->getAWLEN(),
                                       aw_transaction->getAWSIZE(),
                                       aw_transaction->getAWBURST(),
                                       (bool)aw_transaction->getAWLOCK(),
                                       aw_transaction->getAWCACHE(),
                                       aw_transaction->getAWPROT(),
                                       aw_transaction->getAWUSER()); // user /* AXI仕様にないシグナルを使いたい場合に用いる */
				AXIv2_master_TMaster[i]->setSig(AW_LOCK, (fj::uint64)aw_transaction->getAWLOCK());
			}
			else
      {
        /* AWキューにトランザクションがなければAWVALIDを0にする */
				AXIv2_master_TMaster[i]->setSig(AW_VALID, 0);
			}
		}
		break;
	default:
		message(eslapi::CASI_MSG_WARNING,
            "SD_AXIv2_DummyGraphicsMacroModel2Axi::getsendAW: p_Data_Bit_Width <%d> is not supported.",
            p_Data_Bit_Width);
		break;
    }
  }
}

void
	SD_AXIv2_DummyGraphicsMacroModel2Axi::getsendW(void)
{

  for (unsigned int i = 0; i < 2; ++i) {
    uint32_t tmp_wstrb = 0x0;
    
    switch(p_Data_Bit_Width){
    case 64:
      {
        DATA_WIDTH_64               tmp_wdata    = 0x0;
        axi_payload<DATA_WIDTH_64>* w_transaction = NULL;
        w_transaction = core_64->m_transreceiver[i]->frontWTransaction();
        if(w_transaction)
        {
          /* WキューにトランザクションがあればWをセットする */
          tmp_wstrb = (uint32_t)w_transaction->getWSTRB();
          tmp_wdata = w_transaction->getWDATA();
          
          if(tmp_wstrb & 0x0F)
          {
            AXIv2_master_TMaster[i]->setWData((uint32_t)tmp_wdata, 0);
          }
          else
          {
            AXIv2_master_TMaster[i]->setWData(0x00000000, 0);
          }

          if(tmp_wstrb & 0xF0)
          {
            tmp_wdata >>= 32;AXIv2_master_TMaster[i]->setWData((uint32_t)tmp_wdata, 1);
          }
          else
          {
            AXIv2_master_TMaster[i]->setWData(0x00000000, 1);
          }

          AXIv2_master_TMaster[i]->setW(1, // WVALID
                                      w_transaction->getWID(),
                                        tmp_wstrb,
                                        w_transaction->getWLAST(),
                                        0); // user /* AXI仕様にないシグナルを使いたい場合に用いる */
        }
        else
        {
          /* WキューにトランザクションがなければWVALIDを0にする */
          AXIv2_master_TMaster[i]->setSig(W_VALID, 0);
        }
      }
      break;
    default:
      message(eslapi::CASI_MSG_WARNING,
              "SD_AXIv2_DummyGraphicsMacroModel2Axi::getsendW: p_Data_Bit_Width <%d> is not supported.",
              p_Data_Bit_Width);
      break;
    }
  }
}

void
	SD_AXIv2_DummyGraphicsMacroModel2Axi::getsendB(void)
{
  for (unsigned int i = 0; i < 2; ++i) {
    //uint8_t tmp_bid   = 0x0;
    //uint8_t tmp_bresp = 0x0;
    
    unsigned int tmp_bid   = 0x0;
    unsigned int tmp_bresp = 0x0;
    
    
    if(AXIv2_master_TMaster[i]->getSig(B_VALID) && AXIv2_master_TMaster[i]->getSig(B_READY))
    {
      /* B_VALID,B_READYともに1であれば、Bを受信する */
      tmp_bid   = static_cast< unsigned int >( AXIv2_master_TMaster[i]->getSig(B_ID) );
      tmp_bresp = static_cast< unsigned int >( AXIv2_master_TMaster[i]->getSig(B_RESP) );
      
#ifdef ABSTFR_TIMESTAMP
      cout << "[abstFR] B get :: core_id = " << p_core_id << " , sc_time = " << sc_time_stamp() << endl;
#endif
      
      switch(p_Data_Bit_Width){
      case 64:
        {
          axi_payload<DATA_WIDTH_64>* b_transaction = NULL;
          b_transaction = new (axi_payload<DATA_WIDTH_64>);
          b_transaction->setBID(tmp_bid);
          b_transaction->setBRESP(tmp_bresp);
          core_64->m_transreceiver[i]->pushBTransaction(b_transaction);
        }
        break;
      default:
        message(eslapi::CASI_MSG_WARNING,
                "SD_AXIv2_DummyGraphicsMacroModel2Axi::getsendB: p_Data_Bit_Width <%d> is not supported.",
                p_Data_Bit_Width);
        break;
      }
      
      m_b_count--;
      if(m_b_count == 0)
      {
        /* m_b_count == 0によりライト転送完了を判断し、フラグを下げてBREADY=0にする */
        AXIv2_master_TMaster[i]->m_aw_done_flag = 0;
        AXIv2_master_TMaster[i]->m_w_done_flag = 0;
      }
    }
  }
}

void
	SD_AXIv2_DummyGraphicsMacroModel2Axi::getsendAR(void)
{
  for (unsigned int i = 0; i < 2; ++i) {
    switch(p_Data_Bit_Width){
    case 64:
      {
        axi_payload<DATA_WIDTH_64>* ar_transaction = NULL;
        ar_transaction = core_64->m_transreceiver[i]->frontARTransaction();
        if(ar_transaction)
        {
#if 0
          std::cout << sc_time_stamp() << " getsendAR" << std::endl;
#endif
          
          /* ARキューにトランザクションがあればARをセットする */
          AXIv2_master_TMaster[i]->setAR(1, // ARVALID
                                         ar_transaction->getARID(),
                                         (uint64_t)ar_transaction->getARADDR(),
                                         ar_transaction->getARLEN(),
                                         ar_transaction->getARSIZE(),
                                         ar_transaction->getARBURST(),
                                         (bool)ar_transaction->getARLOCK(),
                                         ar_transaction->getARCACHE(),
                                         ar_transaction->getARPROT(),
                                         ar_transaction->getARUSER()); // user /* AXI仕様にないシグナルを使いたい場合に用いる */
          AXIv2_master_TMaster[i]->setSig(AR_LOCK, (fj::uint64)ar_transaction->getARLOCK());
          m_r_count += (ar_transaction->getARLEN() + 1);
        }
        else
        {
          /* ARキューにトランザクションがなければARVALIDを0にする */
          AXIv2_master_TMaster[i]->setSig(AR_VALID, 0);
        }
      }
      break;
    default:
      message(eslapi::CASI_MSG_WARNING,
              "SD_AXIv2_DummyGraphicsMacroModel2Axi::getsendAR: p_Data_Bit_Width <%d> is not supported.",
              p_Data_Bit_Width);
      break;
    }
  }
}

void
	SD_AXIv2_DummyGraphicsMacroModel2Axi::getsendR(void)
{
  for (unsigned int i = 0; i < 2; ++i) {
    //uint8_t  tmp_rid      = 0x0;
    //uint8_t  tmp_rresp    = 0x0;
    //bool     tmp_rlast    = 0x0;
    
    unsigned int tmp_rid	= 0x0;
    unsigned int tmp_rresp	= 0x0;
    unsigned int tmp_rlast	= 0x0;
    
    uint64_t tmp_rdata[4]; //[0]:31-0,[1]:63-32,[2]:95-64,[3]:127:96
    
    if(AXIv2_master_TMaster[i]->getSig(R_VALID) && AXIv2_master_TMaster[i]->getSig(R_READY))
    {
      /* R_VALID,R_READYともに1であれば、Rを受信する */
      tmp_rid   = static_cast< unsigned int >( AXIv2_master_TMaster[i]->getSig(R_ID)		);
      tmp_rresp = static_cast< unsigned int >( AXIv2_master_TMaster[i]->getSig(R_RESP)	);
      tmp_rlast = static_cast< unsigned int >( AXIv2_master_TMaster[i]->getSig(R_LAST)	);
#ifdef ABSTFR_TIMESTAMP
      if(tmp_rlast)
      {
        cout << "[abstFR] R get :: core_id = " << p_core_id << " , sc_time = " << sc_time_stamp() << endl;
      }
#endif
      
      switch(p_Data_Bit_Width){
      case 64:
        {
          axi_payload<DATA_WIDTH_64>* r_transaction   = NULL;
          r_transaction = new (axi_payload<DATA_WIDTH_64>);
          tmp_rdata[0]  = AXIv2_master_TMaster[i]->getRData(0);
          tmp_rdata[1]  = AXIv2_master_TMaster[i]->getRData(1);
          r_transaction->setRID(tmp_rid);
          r_transaction->setRLAST(tmp_rlast);
          r_transaction->setRRESP(tmp_rresp);
          r_transaction->setRDATA(tmp_rdata[0] | (tmp_rdata[1]<<32));
          core_64->m_transreceiver[i]->pushRTransaction(r_transaction);
        }
        break;
      default:
        message(eslapi::CASI_MSG_WARNING,
                "SD_AXIv2_DummyGraphicsMacroModel2Axi::getsendR: p_Data_Bit_Width <%d> is not supported.",
                p_Data_Bit_Width);
        break;
      }
      
      m_r_count--;
      if(m_r_count == 0)
      {
        /* m_r_count == 0によりリード転送完了を判断し、フラグを下げてRREADY=0にする */
        AXIv2_master_TMaster[i]->m_ar_done_flag = 0;
      }
    }
	}
}

int
	SD_AXIv2_DummyGraphicsMacroModel2Axi::getDataWidth(void)
{
	return p_Data_Bit_Width;
}

void
	SD_AXIv2_DummyGraphicsMacroModel2Axi::controlInterrupt(void)
{
	for(fj::uint32 interrupt_number = 0; interrupt_number < 4; interrupt_number ++)
	{
    m_signal_interrupt[interrupt_number].write(m_interrupt_1bit[interrupt_number]);
	}
	//std::cout << "[INFO]SD_AXIv2_DummyGraphicsMacroModel2Axi::controlInterrupt interrupt = " << (fj::uint32)interrupt_value 
	//          << " at " << sc_time_stamp() << std::endl;
}

void 
	SD_AXIv2_DummyGraphicsMacroModel2Axi::controlOutput(void)
{
	fj::uint32   tmp_array[4];

 	for(fj::uint32 output_number = 0; output_number < 4; output_number ++)
	{
		if(core_64->m_output_receiver->get(output_number) != m_previous_output_value[output_number]) {
      output_SMaster[output_number]->driveSignal(core_64->m_output_receiver->get(output_number), tmp_array);
      m_previous_output_value[output_number] = core_64->m_output_receiver->get(output_number);
		}
  }
}

/* FSL code begin */

void SD_AXIv2_DummyGraphicsMacroModel2Axi::init()
{

	// Initialize ourself for save/restore.
	initStream( this );

  for (unsigned int i = 0; i < 2; ++i) {
    AXIv2_master_TMaster[i]->init(p_Address_Bit_Width, p_Data_Bit_Width);
  }

	// Allocate memory and initialize data here:
	// ...
  
	/* FSL code begin */
	m_b_count = 0x0;
	m_r_count = 0x0;

	core_64 = NULL;

	m_signal_reset_x = 0x1;

	for(fj::uint32 i = 0; i < 4; i ++)
	{
    m_signal_interrupt[i]  = 0x0;
    m_signal_output[i] = 0x0;
		m_interrupt_1bit[i] = false;
    m_previous_output_value[i] = 0x0;
	}

	sc_time_unit time_unit; // sc_time_unit for DummyGraphicsMacroModel

	if     (p_time_unit == "SC_FS")  {time_unit = SC_FS;}
	else if(p_time_unit == "SC_PS")  {time_unit = SC_PS;}
	else if(p_time_unit == "SC_NS")  {time_unit = SC_NS;}
	else if(p_time_unit == "SC_US")  {time_unit = SC_US;}
	else if(p_time_unit == "SC_MS")  {time_unit = SC_MS;}
	else if(p_time_unit == "SC_SEC") {time_unit = SC_SEC;}
	else                             {time_unit = SC_NS;}

	switch(p_Data_Bit_Width){
	case 64:
		core_64 = new DummyGraphicsMacroModel_wrapperbase<DATA_WIDTH_64, 2>(p_model_id,
                                                                        p_rch_number,
                                                                        p_wch_number,
                                                                        p_core_number,
                                                                        p_read_outstanding_number,
                                                                        p_write_outstanding_number,
                                                                        p_no_r_receive,
                                                                        p_no_b_receive,
                                                                        time_unit,
                                                                        p_axi_clock,
                                                                        p_core_clock,
                                                                        p_buffer_parameter_file_name.c_str(),
                                                                        p_output_vcd_file_name.c_str(),
                                                                        p_output_csv_file_name.c_str(),
                                                                        p_output_summary_file_name.c_str()
                                                                        );
		//core_64->reset_x(m_signal_reset_x);
    for (unsigned int i = 0; i < 2; ++i) {
      core_64->m_transreceiver[i]->m_clk( *(getMxSCClock()) );
    }
		break;
	default:
		message(eslapi::CASI_MSG_WARNING,
			"FRBMx2::init: p_Data_Bit_Width <%d> is not supported.",
			p_Data_Bit_Width);
		break;
	}
	/* FSL code end */

	// Call the base class after this has been initialized.
	CASIModule::init();
}

void SD_AXIv2_DummyGraphicsMacroModel2Axi::reset(eslapi::CASIResetLevel level, const CASIFileMapIF *filelist)
{
	// Add your reset behavior here:
	// ...

  for (unsigned int i = 0; i < 2; ++i) {
    AXIv2_master_TMaster[i]->reset();
  }

	// Call the base class after this has been reset.
	CASIModule::reset(level, filelist);
}

void SD_AXIv2_DummyGraphicsMacroModel2Axi::terminate()
{
	// Call the base class first.
	CASIModule::terminate();


	// Free memory which has been allocated in init stage
	// ...

	/* FSL code start */
  delete core_64;
	/* FSL code end */
}

void SD_AXIv2_DummyGraphicsMacroModel2Axi::setParameter( const string &name, const string &value )
{
	CASIConvertErrorCodes status = CASIConvert_SUCCESS;

  if (name == "Enable Debug Messages")
  {
    status = CASIConvertStringToValue( value, &p_enableDbgMsg  );
  }
  else if (name == "model_id")
  {
		status = CASIConvertStringToValue( value, &p_model_id );
	}
	else if (name == "rch_number")
	{
		status = CASIConvertStringToValue( value, &p_rch_number );
	}
	else if (name == "wch_number")
	{
		status = CASIConvertStringToValue( value, &p_wch_number );
	}
	else if (name == "core_number")
	{
		status = CASIConvertStringToValue( value, &p_core_number );
	}
	else if (name == "read_outstanding_number")
	{
		status = CASIConvertStringToValue( value, &p_read_outstanding_number );
	}
	else if (name == "write_outstanding_number")
	{
		status = CASIConvertStringToValue( value, &p_write_outstanding_number );
	}
	else if (name == "no_r_receive")
	{
		status = CASIConvertStringToValue( value, &p_no_r_receive );
	}
	else if (name == "no_b_receive")
	{
		status = CASIConvertStringToValue( value, &p_no_b_receive );
	}
	else if (name == "time_unit")
	{
		p_time_unit = value;
	}
	else if (name == "axi_clock")
	{
		status = CASIConvertStringToValue( value, &p_axi_clock );
	}
	else if (name == "core_clock")
	{
		status = CASIConvertStringToValue( value, &p_core_clock );
	}
	else if (name == "buffer_parameter_file_name")
	{
		p_buffer_parameter_file_name =  value;
	}
	else if (name == "output_vcd_file_name")
	{
		p_output_vcd_file_name =  value;
	}
	else if (name == "output_csv_file_name")
	{
		p_output_csv_file_name =  value;
	}
	else if (name == "output_summary_file_name")
	{
		p_output_summary_file_name =  value;
	}
	else if (name == "Data Width")
	{
		status = CASIConvertStringToValue( value, &p_Data_Bit_Width );
	}
	else if (name == "Address Width")
	{
		status = CASIConvertStringToValue( value, &p_Address_Bit_Width );
	}

	if ( status == CASIConvert_SUCCESS )
	{
		CASIModule::setParameter(name, value);
	}
	else
	{
		message( eslapi::CASI_MSG_WARNING, "SD_AXIv2_DummyGraphicsMacroModel2Axi::setParameter: Illegal value <%s> passed for parameter <%s>. Assignment ignored.", value.c_str(), name.c_str() );
	}
}

string SD_AXIv2_DummyGraphicsMacroModel2Axi::getProperty( eslapi::CASIPropertyType property )
{
	string description; 
	switch ( property ) 
	{    
	case eslapi::CASI_PROP_LOADFILE_EXTENSION:
		return "";
	case eslapi::CASI_PROP_REPORT_FILE_EXT:
		return "yes";
	case eslapi::CASI_PROP_COMPONENT_TYPE:
		return "Core"; 
	case eslapi::CASI_PROP_COMPONENT_VERSION:
		return "0.1";
	case eslapi::CASI_PROP_MSG_PREPEND_NAME:
		return "yes"; 
	case eslapi::CASI_PROP_DESCRIPTION:
		description = "SD_AXIv2_DummyGraphicsMacroModel2Axi";
		return description + " Compiled on " + __DATE__ + ", " + __TIME__; 
	case eslapi::CASI_PROP_CADI_SUPPORT:
		return "no";
	case eslapi::CASI_PROP_SAVE_RESTORE:
		return "yes";
	default:
		return "";
	}
}

string SD_AXIv2_DummyGraphicsMacroModel2Axi::getName(void)
{
	return "SD_AXIv2_DummyGraphicsMacroModel2Axi";
}

bool
	SD_AXIv2_DummyGraphicsMacroModel2Axi::saveData( CASIODataStream &data )
{
	// TODO:  Add your save code here.
	// This shows how the example state variable is saved.
	// data << exampleStateVariable;

	// TODO:  Add verification if applicable.
	// return save was successful
	return true;
}

bool
	SD_AXIv2_DummyGraphicsMacroModel2Axi::restoreData( CASIIDataStream &data )
{
	// TODO:  Add your restore code here.
	// This shows how the example state variable is restored.
	// data >> exampleStateVariable;

	// TODO:  Add verification if applicable.
	// return restore was successful
	return true;
}

void
	SD_AXIv2_DummyGraphicsMacroModel2Axi::initSignalPort(CASISignalMasterIF* signalIf)
{
	CASISignalProperties prop_sm1;
	memset(&prop_sm1, 0, sizeof(prop_sm1));
	prop_sm1.isOptional = false;
	prop_sm1.bitwidth = 32;
	signalIf->setProperties(&prop_sm1);
}

// This initAXIv2TransactionPort() is only called for AXIv2 Transaction Master Ports.
// Do not call this function for any port which has its own initialization code.
void
	SD_AXIv2_DummyGraphicsMacroModel2Axi::initAXIv2TransactionPort(CASITransactionMasterIF* transIf)
{
	CASITransactionProperties prop;
	memset(&prop, 0, sizeof(prop));
	prop.casiVersion = eslapi::CASI_VERSION_1_1;     //the transaction version used for this transaction
	prop.useMultiCycleInterface = false;    // using read/write interface methods
	prop.addressBitwidth = 32;      // address bitwidth used for addressing of resources 
	prop.mauBitwidth = 8;           // minimal addressable unit 
	prop.dataBitwidth = 32;         // maximum data bitwidth transferred in a single cycle 
	prop.isLittleEndian = true;     // alignment of MAUs 
	prop.isOptional = false;        // if true this port can be disabled 
	prop.supportsAddressRegions = true;  // M/S can negotiate address mapping
	prop.numCtrlFields = 1;         // # of ctrl elements used / entry is used for transfer size


  // prop.protocolID = 0x0002A3E1;           // magic number for the AXIv2 protocol 
  prop.protocolID = AXI2_PROTOCOL_ID;           // magic number for the AXIv2 protocol 


  sprintf(prop.protocolName,"AXIv2");         // The name of the  protocol being used
	// CASI : slave port address regions forwarding 
	prop.isAddrRegionForwarded = false; //true if addr region for this slave port is actually 
	//forwarded to a master port, false otherwise
	prop.forwardAddrRegionToMasterPort = NULL; //master port of the  same component to which this slave port's addr region is forwarded
	transIf->setProperties(&prop);
}

/************************
* SD_AXIv2_DummyGraphicsMacroModel2Axi Factory class
***********************/
class SD_AXIv2_DummyGraphicsMacroModel2AxiFactory : public CASIFactory
{
public:
	SD_AXIv2_DummyGraphicsMacroModel2AxiFactory() : CASIFactory ( "SD_AXIv2_DummyGraphicsMacroModel2Axi" ) {}
	CASIModuleIF *createInstance(CASIModuleIF *c, const string &id)
	{ 
		return new SD_AXIv2_DummyGraphicsMacroModel2Axi(c, id); 
	}
};

/**
*  Entry point into the memory components (from SoC Designer)
*/
extern "C" void 
	CASIInit(void)
{
	new SD_AXIv2_DummyGraphicsMacroModel2AxiFactory();
}
